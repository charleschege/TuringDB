use redactedsecret::SecretString;
use tai64::TAI64N;
use std::{
    iter,
    path::PathBuf
};

use rand::{
    Rng,
    thread_rng,
    distributions::Alphanumeric,
};

use crate::{
    TuringFeedsError,
};

pub type Result<T> = std::result::Result<T, TuringFeedsError>;

pub type UserIdentifier = SecretString;
pub type AutoGeneratedIdentifier = String; // Enables sharding and multicluster identification
pub type UserDefinedName = String;
pub type CorruptionGuard = (PathBuf, u64); // (Path, seahash)
pub type Blake2hash = String;
pub type SeaHashCipher = u64;
pub type NoOfEntries = usize;
pub type CreateTaiTime = TAI64N;
pub type ModifiedTaiTime = TAI64N;
pub type RandIdentifierString = String;

#[derive(Debug, PartialEq, Clone)]
pub struct RandIdentifier;

impl RandIdentifier {
    pub async fn build() -> String {
        let mut rng = thread_rng();
        
        iter::repeat(())
            .map(|()| rng.sample(Alphanumeric))
            .take(64)
            .collect::<String>()
    }
}

#[derive(Debug)]
pub enum AccessRights {
    Table(String),
    Db(String),
}

#[derive(Debug)]
pub enum Role {
    SuperUser,
    Admin,
    SubAdmin,
    User,
}

#[derive(Debug)]
pub enum DbType {
    KeyValueStore,
    RealTimeFeeds,
}