use async_std::{
    task,
    fs::{File, OpenOptions, DirBuilder},
    net::{TcpListener, TcpStream},
	io::{prelude::*, BufReader, ErrorKind},
	path::PathBuf,
};
use std::{collections::HashMap, io::Read};
use custom_codes::{FileOps, DbOps};
use tai64::TAI64N;
use serde::{Serialize, Deserialize};

use crate::{
	UserIdentifier, 
	Role, 
	AccessRights, 
	TuringFeedsError, 
	AutoGeneratedIdentifier, 
	UserDefinedName, 
	SeaHashCipher, 
	NoOfEntries, 
	CreateTaiTime, 
	ModifiedTaiTime,
	RandIdentifier,
	RandIdentifierString,
	Result,
};

/// No need for rights as the user who decrypts the DB has total access

#[derive(Debug, Serialize, Deserialize)]
pub struct TuringFeeds {
	created: TAI64N,
	dbs: Option<HashMap<UserDefinedName, TuringFeedsDB>>,
	//hash: RepoBlake2hash,
	//secrecy: TuringSecrecy,
	//config: TuringConfig,
	//authstate: Assymetric Crypto
	//superuser: Only one
	// admins: vec![], -> (User, PriveledgeAccess)
	//users: vec![] -> ""
}

impl TuringFeeds {
	/// Initialize the structure with default values
	pub async fn new() -> Self {
		Self { created: TAI64N::now(), dbs: Option::default(), }
	}
	/// Recursively walk through the Directory
	/// Load all the Directories into memory
	/// Hash and Compare with Persisted Hash to check for corruption
	/// Throw errors if any otherwise 
	pub async fn init(self) -> Result<TuringFeeds> {
		let mut repo_path = PathBuf::new();
		repo_path.push("TuringFeeds");
		repo_path.push("REPO");
		repo_path.set_extension("log");

		let file = OpenOptions::new()
			.create(false)
			.read(true)
			.append(true)
			.open(repo_path).await?;

		let mut buffer = BufReader::new(file);
		let mut raw = String::new();

		buffer.read_line(&mut raw).await?;

		Ok(ron::de::from_str::<Self>(&raw)?)
	}
	/// Create a new repository/directory that contains the databases
	pub async fn create() -> Result<FileOps> {
		let mut repo_path = PathBuf::new();
		repo_path.push("TuringFeeds");
		
		match DirBuilder::new()
			.recursive(false)
			.create(repo_path)
			.await {
				Ok(_) => Ok(FileOps::CreateTrue),
				Err(error) => Err(TuringFeedsError::IoError(error)),
			}
	}
	/// Create the Metadata file
	pub async fn metadata(self) -> Result<FileOps>{

		let mut repo_path = PathBuf::new();
		repo_path.push("TuringFeeds");
		repo_path.push("REPO");
		repo_path.set_extension("log");

		match OpenOptions::new()
		.create(true)
		.read(false)
		.append(true)
		.open(repo_path).await {
			Ok(mut file) => {
				let data = ron::ser::to_string(&self)?.as_bytes().to_owned();
				file.write_all(&data).await?;
				file.sync_all().await?;
				
				Ok(FileOps::CreateTrue)
			},
			Err(error) => Err(TuringFeedsError::IoError(error)),
		}
	}
	/// Add or Modify a Database
	pub async fn memdb_add(mut self, values: TuringFeedsDB) -> (DbOps, Self) {
		if let Some(mut existing_map) = self.dbs {
			match existing_map.insert(values.identifier.clone(), values) {
				Some(_) => { // If the value existed in the map
					self.created = TAI64N::now();
					self.dbs = Some(existing_map);
					(DbOps::Modified, self)
				},
				None => {
					self.created = TAI64N::now();
					self.dbs = Some(existing_map);
					(DbOps::Inserted, self)
				},
			}
		}else {
			let mut new_map = HashMap::new();
			new_map.insert(values.identifier.clone(), values);
			self.created = TAI64N::now();
			self.dbs = Some(new_map);

			(DbOps::Inserted, self)
		}
	}
	/// Add a Database if it does not exist
	pub async fn memdb_rm(mut self, key: &str) -> (DbOps, Self) {
		if let Some(mut existing_map) = self.dbs {
			match existing_map.remove(key) {
				Some(_) => { // If the value existed in the map
					self.created = TAI64N::now();
					self.dbs = Some(existing_map);
					(DbOps::Deleted, self)
				},
				None => {
					// If the key does not exist in the map
					self.dbs = Some(existing_map);
					(DbOps::KeyNotFound, self)
				},
			}
		}else {
			// The Repository does not have any databases
			(DbOps::Empty, self)
		}
	}
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TuringFeedsDB {	
	identifier: UserDefinedName,
	datetime: TAI64N,
	document_list: Option<HashMap<UserDefinedName, TFDocument>>,
	//rights: Option<HashMap<UserIdentifier, (Role, AccessRights)>>,
	//database_hash: Blake2hash,
	//secrecy: TuringSecrecy,
	//config: TuringConfig,
	//authstate: Assymetric Crypto
	//superuser: Only one
	// admins: vec![], -> (User, PriveledgeAccess)
	//users: vec![] -> """"
}

impl TuringFeedsDB {
	pub async fn new() -> Self {
		Self {
			identifier: String::default(),
			datetime: TAI64N::now(),
			document_list: Option::default(),
		}
	}
	pub async fn identifier(mut self, key: &str) -> Self {
		self.identifier = key.to_owned();

		self
	}
	pub async fn memdb_add(mut self, values: TFDocument) -> Self {
		if let Some(mut existing_map) = self.document_list {
			match existing_map.insert(values.identifier.clone(), values) {
				Some(_) => { // If the value existed in the map
					self.datetime = TAI64N::now();
					self.document_list = Some(existing_map);
					
					self
				},
				None => {
					self.datetime = TAI64N::now();
					self.document_list = Some(existing_map);
					
					self
				},
			}
		}else {
			let mut new_map = HashMap::new();
			new_map.insert(values.identifier.clone(), values);
			self.datetime = TAI64N::now();
			self.document_list = Some(new_map);

			self
		}
	}
	pub async fn memdb_rm(mut self, key: &str) -> (DbOps, Self) {
		if let Some(mut existing_map) = self.document_list {
			match existing_map.remove(key) {
				Some(_) => { // If the value existed in the map
					self.datetime = TAI64N::now();
					self.document_list = Some(existing_map);
					(DbOps::Deleted, self)
				},
				None => {
					// If the key does not exist in the map
					self.document_list = Some(existing_map);
					(DbOps::KeyNotFound, self)
				},
			}
		}else {
			// The Repository does not have any databases
			(DbOps::Empty, self)
		}
	}
}

// Get structure from file instead of making it a `pub` type
#[allow(unused_variables)]
#[derive(Debug, Serialize, Deserialize)]
enum Structure {
	Schemaless,
	Schema,
	Vector,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TFDocument {
	// Gives the document path
	identifier: RandIdentifierString,
	//primary_key: Option<UserDefinedName>,
	//indexes: Vec<String>,
	//hash: SeaHashCipher,
	create_time: CreateTaiTime,
	modified_time: ModifiedTaiTime,
	//structure: Structure,
}

impl TFDocument {
	pub async fn new() -> Self {
		let time_now = TAI64N::now();

		Self {
			identifier: RandIdentifier::build().await,
			//primary_key: Option::default(),
			//indexes: Vec::default(),
			//hash: Default::default(),
			create_time: time_now,
			modified_time: time_now,
		}
	}
	pub async fn id(mut self, value: &str) -> Self {
		self.identifier = value.to_owned();

		self
	}
}

#[derive(Debug, Serialize, Deserialize)]
enum DocumentRights {
	/// Create Access
	C,
	/// Read Access
	R,
	/// Write Access
	W,
	/// Delete Access
	D,
	/// Forward
	F,
	/// Create Read Write Delete Access
	CRWD,
	/// Read Write Access
	RW,
}

struct TFTable {
	identifier: AutoGeneratedIdentifier,
	indexes: Vec<String>,
	primary_key: Option<String>,
	secrecy: TuringSecrecy,
}

enum TuringConfig {
	DefaultCOnfig,
	WriteACKs,

}
	// Shows the level of security from the database level to a document level
enum TuringSecrecy {
	DatabaseMode,
	TableMode,
	DocumentMode,
	DefaultMode,
	InactiveMode,
}